DatabaseHelper helper = DatabaseHelper();

class NotesBloc implements BlocBase {
  // Create a broadcast controller that allows this stream to be listened
  // to multiple times. This is the primary, if not only, type of stream you'll be using.
  final _notesController = StreamController<List<Product>>.broadcast();

  // Input stream. We add our notes to the stream using this variable.
  StreamSink<List<Product>> get _inProducts => _notesController.sink;

  // Output stream. This one will be used within our pages to display the notes.
  Stream<List<Product>> get notes => _notesController.stream;

  // Input stream for adding new notes. We'll call this from our pages.
  final _addProductController = StreamController<Product>.broadcast();
  StreamSink<Product> get inAddProduct => _addProductController.sink;

  NotesBloc() {
    // Retrieve all the notes on initialization
    getProducts();

    // Listens for changes to the addProductController and calls _handleAddProduct on change
    _addProductController.stream.listen(_handleAddProduct);
  }

  // All stream controllers you create should be closed within this function
  @override
  void dispose() {
    _notesController.close();
    _addProductController.close();
  }

  void getProducts() async {
    // Retrieve all the notes from the database
    List<Product> notes = await helper.getProductList();

    // Add all of the notes to the stream so we can grab them later from our pages
    _inProducts.add(notes);
  }

  void _handleAddProduct(Product note) async {
    // Create the note in the database
    await helper.insertProduct(note);

    // Retrieve all the notes again after one is added.
    // This allows our pages to update properly and display the
    // newly added note.
    getProducts();
  }
}
